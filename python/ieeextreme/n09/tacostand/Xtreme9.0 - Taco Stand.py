#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import io
import math

DEBUG = False

def readString(reader):
    return reader.readline().replace("\n","")

def readInt(reader):
    line = reader.readline().replace("\n","")
    if line=="":
        return None
    else:
        return int(line)

"""
He always insists on fresh ingredients, so any leftover ingredients on a given day will be thrown away.
"""
"""
His ingredients are:
0) Taco shells - every taco gets exactly one of these
1) Meat
2) Rice
3) Beans
His recipe is to take one taco shell, then add exactly two of the ingredients: 
meat, rice, and beans. 
So, for example, one taco might have meat and rice, 
while another taco might be made with rice and beans. 
However, a taco cannot have two of the same ingredient. 
For example, Joe will never make a taco with two servings of meat.
"""
"""
Your task is to write a program to calculate the maximum number of tacos Joe can make each day, 
given the amount of ingredients he will have.
"""
def main(argv):

    reader = io.open(sys.stdin.fileno())

    """
    The first line of input is an integer n, 1 <= n <= 1000, 
    specifying how many days Joe will be making tacos.
    """
    n = readInt(reader)

    for i in range(n):

        s, m, r, b = getIngredients(reader)
        if DEBUG:
            print(s)
            print(m)
            print(r)
            print(b)

        t = EditorialMethod(m, r, b)
        print(min(s, t))
    """
    Output Format
    The output file is exactly n lines long, 
    each line containing an integer specifying the maximum number of tacos 
    Joe can make with that dayâ€™s ingredients.
    Note: There is a newline character at the end of the last line of the output.
    """

"""
The following n lines contain 4 space-separated integers in the format:
s m r b
where s is the number of shells available, 
m is the amount of meat, 
r is the amount of rice, 
and b is the amount of beans, 
each expressed in terms of the number of tacos they could make.
Note: s, m, r, and b are all non-negative integers less than 10^9.
"""
def getIngredients(reader):
    line = readString(reader)
    ingredients = line.split(" ")
    return int(ingredients[0]), int(ingredients[1]), int(ingredients[2]), int(ingredients[3])

def MyMethod(m, r, b):
    """
    x+y <= m
    x+z <= r
    y+z <= b
    """
    """
    x <= (1/2)*(m+r-b)
    y <= (1/2)*(m-r+b)
    z <= (1/2)*(-m+r+b)
    """
    x1 = (1 / 2) * (m + r - b)
    if x1 < 0:
        x1 = 0
    y1 = (1 / 2) * (m - r + b)
    if y1 < 0:
        y1 = 0
    z1 = (1 / 2) * (-m + r + b)
    if z1 < 0:
        z1 = 0
    if DEBUG:
        print(x1)
        print(y1)
        print(z1)

    """
    x <= m-y
    y <= b-z
    z <= r-x
    """
    x2 = m - y1
    if x2 < 0:
        x2 = 0
    y2 = b - z1
    if y2 < 0:
        y2 = 0
    z2 = r - x1
    if z2 < 0:
        z2 = 0
    if DEBUG:
        print(x2)
        print(y2)
        print(z2)

    """
    x <= r-z
    y <= m-x
    z <= b-y
    """
    x3 = r - z2
    if x3 < 0:
        x3 = 0
    y3 = m - x2
    if y3 < 0:
        y3 = 0
    z3 = b - y2
    if z3 < 0:
        z3 = 0
    if DEBUG:
        print(x3)
        print(y3)
        print(z3)

    x = min(x1, x2, x3)
    y = min(y1, y2, y3)
    z = min(z1, z2, z3)
    if DEBUG:
        print(x)
        print(y)
        print(z)
    return math.floor(x + y + z)

def median(lst):
    n = len(lst)
    if n < 1:
            return None
    if n % 2 == 1:
            return sorted(lst)[n//2]
    else:
            return sum(sorted(lst)[n//2-1:n//2+1])/2.0

def EditorialMethod(m, r, b):
    """
    In this problem you are asked to help Joe maximize the number of tacos that could be made.
    Another way of looking at this is to try to minimize the number of unused ingredients.
    We will take this later approach,
    considering first the pairings of taco fillings that could be used.
    """
    """
    Let r be the number of rice servings,
    m be the number of meat servings,
    and b be the number of bean servings.    
    """
    """
    Furthermore, let:
    x = min(r, m, b), i.e. the smallest quantity of all fillings
    y = median(r, m, b), i.e. the middle quantity of all fillings
    z = max(r, m, b), i.e. the largest quantity of all fillings
    We will refer to x-type, y-type, and z-type ingredients to mean the type of the corresponding filling.
    """
    x = min(r, m, b)
    y = median([r, m, b])
    z = max(r, m, b)

    if z > x + y:
        """
        Scenario 1: z > x + y
        Here the maximum number of filling combinations we can create 
        is generated by using the z-type filling in every taco, 
        with one of the other fillings. 
        So if s is the number of taco shells we have, 
        the number of tacos Joe can make is the min(s, x + y).
        """
        return x+y
    else:
        """
        Scenario 2: z <= x + y
        In scenario 2, we will take an approach that, given sufficient taco shells, 
        will use all but at most one of the fillings. 
        We will start by making tacos with the x-type filling and the z-type filling, 
        reducing z until it becomes equal with y.
        Then, while there are still two x-type fillings remaining, 
        we will make two tacos - one with x-type and y-type fillings, 
        and one with x-type and z-type fillings. 
        By making pairs of tacos at a time, y stays equal to z.
        Once we down to less than 2 remaining x-type fillings, 
        we will make tacos using y-type and z-type fillings. 
        Since there are an equal number of both of these, 
        we can use all of the y-type and z-type ingredients.
        Since we know how to use all (but perhaps one) of the ingredients in this case, 
        we can come up with a simple formula for the number of tacos. 
        Letting s be the number of taco shells we have, 
        the number of tacos Joe can make is the min(s, floor((x + y + z)/2)).
        """
        return math.floor((x+y+z)/2)

if __name__ == "__main__":
    main(sys.argv)